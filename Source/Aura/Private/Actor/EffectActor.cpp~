// Fill out your copyright notice in the Description page of Project Settings.


#include "Actor/EffectActor.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "AbilitySystemComponent.h"
#include "Containers/Map.h"

AEffectActor::AEffectActor()
{
	PrimaryActorTick.bCanEverTick = false;

    SetRootComponent(CreateDefaultSubobject<USceneComponent>("SceneRoot"));
}

void AEffectActor::BeginPlay()
{
	Super::BeginPlay();
}

TOptional<FGameplayEffectSpecHandle> AEffectActor::ConstructEffectSpec(
        AActor* TargetActor, TSubclassOf<UGameplayEffect> GamePlayEffectClass) {
    // 我用这个方法封装EffectSpec, 方法返回后Effect Spec中的EffectSpec.Data.Get()->Def.Get()->DurationPolicy会变得不可访问
    return {};
}


void AEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf<UGameplayEffect> GamePlayEffectClass) {
    auto TargetAbilitySystemComponent = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);

    if (!TargetAbilitySystemComponent) return;

    check(GamePlayEffectClass);

    auto EffectContextHandle = TargetAbilitySystemComponent->MakeEffectContext();
    EffectContextHandle.AddSourceObject(this);
    auto EffectSpec = TargetAbilitySystemComponent->MakeOutgoingSpec(GamePlayEffectClass, 1.f, EffectContextHandle);
   
    auto DurationPolicy = EffectSpec.Data.Get()->Def.Get()->DurationPolicy;

    switch (DurationPolicy) {
        case EGameplayEffectDurationType::Instant :
        case EGameplayEffectDurationType::HasDuration :
            {
                ApplyEffect(TargetActor, EffectSpec, GamePlayEffectClass);
                break;
            }
        case EGameplayEffectDurationType::Infinite :
            {
                auto ActiveEffect = ApplyEffect(TargetActor, EffectSpec, GamePlayEffectClass);

                if (EffectRemovalPolicy == EEffectRemovalPolicy::RemoveOnEndOverlap) {
                    ActorActiveEffectsMap.Add(TargetActor->GetUniqueID(), ActiveEffect);
                }
                break;
            }
        default:
            break;
    }
}

FActiveGameplayEffectHandle AEffectActor::ApplyEffect(AActor* TargetActor, FGameplayEffectSpecHandle EffectSpec, TSubclassOf<UGameplayEffect> GamePlayEffectClass) {
    auto TargetAbilitySystemComponent = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);

    return TargetAbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
}

void AEffectActor::RemoveActiveEffect(AActor* TargetActor) {
    if (EffectRemovalPolicy == EEffectRemovalPolicy::DoNotRemove) {
        return;
    }

    auto TargetAbilitySystemComponent = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);
    auto TargetActorUID = TargetActor->GetUniqueID();

    if (ActorActiveEffectsMap.Contains(TargetActorUID)) {
        auto ActiveEffect = ActorActiveEffectsMap[TargetActorUID];
        TargetAbilitySystemComponent->RemoveActiveGameplayEffect(ActiveEffect, 1);
        // TargetAbilitySystemComponent->RemoveActiveGameplayEffectBySourceEffect(GameplayEffectClass, )

        ActorActiveEffectsMap.Remove(TargetActorUID);
    }
}
